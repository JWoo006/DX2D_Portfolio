//
// 종횡비 - 버텍스 셰이더에서 구현 및 조정
// 
// 오브젝트 이동
// ㄴ 버텍스 좌표 이동
// ㄴ cpu에서 0.2만큼 이동시킬 변수(f)를 HLSL GPU에서 변수를 받아서 적용
// ㄴ 램(cpu)와 GPU 간 데이터를 이동시킬 상수 버퍼가 필요
// 
// 카타나 제로 시간 돌리기 화면왜곡(구불구불)
// ㄴ sin() cos() 을 버텍스 셰이더나 픽셀 셰이더에서 연산
// ㄴ 2파이에 1과 -1을 넘나드는 상수를 입력하는 상수를 상수버퍼로 사용
// ㄴ 상수버퍼 사용시 cpu에 부하가 걸림 적당히 사용
// 
// 하복엔진
// 타임, 간단한 위치 연산 - cpu
// 렌더링 - gpu - 대게 물리를 cpu에서 처리하는 라이브러리가 많지많지만 nvidia 피직스는 gpu에서 물리 처리
// 
// gpu 동작원리
// ㄴ GPU는 어떻게 작동할까 유튜브 참고
// ㄴ gpu는 수천개의 프로세서가 내장되어있어 간단한 병렬 연산에 최적화되어있다.
// ㄴ 순차계산이아닌 동시다발적으로 픽셀 처리가 가능 - 대량의 데이터 처리 가능
// ㄴ SIMT(쓰레드 중심 처리)방식
// ㄴ 지연시간 - 쓰레드 처리 중 메모리에서 쓰레드를 받는 동안 처리가 멈추는 시간 - 코어 근처의 캐쉬메모리를 사용해 지연시간 낮춤
//
// 게임에 맞춰서 cpu처리와 gpu처리를 결정해주는 것이 프로그래머의 역량
// 
// 인덱스 버퍼
// ㄴ 정점 순서가 아닌 정점을 그려주는 순서를 정해주는 버퍼
// 
// 렌더러 클래스에서 삼각형 인덱스 버퍼, 상수 버퍼 변수를 추가
// 로드 버퍼 함수에서 인덱스 버퍼 할당
// 인덱스 버퍼는 정수데이터를 가진다.
// 정수를 가질 UINT형 벡터를 생성해서 벡터 사이즈 만큼 크기 전달 desc.Usage
// 
// 상수 버퍼
// ㄴ cpuacessflag = d3d11_cpu_acess_write <- 값이 바뀔수 있어야함
// ㄴ 상수 버퍼 넘길 변수 규칙 -> 16바이트 크기로 바이트 패딩해서 넘겨여함
// ㄴ 12바이트도 20바이트도 안됨 
// 
// 행렬
// ㄴ GPU 내부 연산은 기본적으로 행렬로 병렬 연산을 사용한다.
// ㄴ 16바이트와 4 X 4 행렬 기반의 데이터로 연산하기 때문에 16바이트로 패딩하여 상수버퍼를 사용
// 
// 그래픽 디바이스 클래스 - 바인드상수버퍼함수 추가
// set상수버퍼 추가 - 인자 -> 버퍼, 정수 데이터
// 그래픽 cpp에 셰이더 스테이지 enum class 생성, CB enum 추가 - transform
// subres 와 상수버퍼를 맵핑 컨텍스트 -> Map()사용
// ㄴ subres는 함수내 지역 변수여서 함수 종료전 할당해제
// 바인드 상수버퍼 함수에 상수 버퍼 열거체 스위치문으로 구현
// 이후 상수버퍼의 정수를 셰이더에서 사용해야함
// ㄴ cbuffer transform : register()
// ㄴ 몇번 레지스터에 할당
// 받은데이터 버텍스 셰이더 적용
// 버퍼의 데이터를 저장하고 (전역변수) 바인딩하기
// pos 변수를 전역화 인풋을 입력 구현
// 
// 숙제 
// ㄴ 키보드 입력으로 삼각형 움직이기
// 
// 인덱스 버퍼로 도형 그리기
// ㄴ 그래픽 디바이스 클래스 렌더러에서 인덱스 버퍼 설정
// ㄴ 인덱스 드로우함수로 그리기
// 
// 
// 
//